
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>kademlia: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/albernnV/D7024E/pkg/kademlia/bucket.go (94.7%)</option>
				
				<option value="file1">github.com/albernnV/D7024E/pkg/kademlia/contact.go (100.0%)</option>
				
				<option value="file2">github.com/albernnV/D7024E/pkg/kademlia/kademlia.go (48.5%)</option>
				
				<option value="file3">github.com/albernnV/D7024E/pkg/kademlia/kademliaid.go (100.0%)</option>
				
				<option value="file4">github.com/albernnV/D7024E/pkg/kademlia/network.go (60.8%)</option>
				
				<option value="file5">github.com/albernnV/D7024E/pkg/kademlia/routingtable.go (93.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package kademlia

import (
        "container/list"
)

// bucket definition
// contains a List
type bucket struct {
        list *list.List
}

// newBucket returns a new instance of a bucket
func newBucket() *bucket <span class="cov10" title="483">{
        bucket := &amp;bucket{}
        bucket.list = list.New()
        return bucket
}</span>

// AddContact adds the Contact to the front of the bucket
// or moves it to the front of the bucket if it already existed
func (bucket *bucket) AddContact(contact Contact) <span class="cov4" title="13">{
        var element *list.Element
        for e := bucket.list.Front(); e != nil; e = e.Next() </span><span class="cov4" title="15">{
                nodeID := e.Value.(Contact).ID

                if (contact).ID.Equals(nodeID) </span><span class="cov1" title="1">{
                        element = e
                }</span>
        }

        <span class="cov4" title="13">if element == nil </span><span class="cov4" title="12">{
                if bucket.list.Len() &lt; bucketSize </span><span class="cov4" title="12">{
                        bucket.list.PushFront(contact)
                }</span>
        } else<span class="cov1" title="1"> {
                bucket.list.MoveToFront(element)
        }</span>
}

// GetContactAndCalcDistance returns an array of Contacts where
// the distance has already been calculated
func (bucket *bucket) GetContactAndCalcDistance(target *KademliaID) []Contact <span class="cov8" title="161">{
        var contacts []Contact

        for elt := bucket.list.Front(); elt != nil; elt = elt.Next() </span><span class="cov4" title="8">{
                contact := elt.Value.(Contact)
                contact.CalcDistance(target)
                contacts = append(contacts, contact)
        }</span>

        <span class="cov8" title="161">return contacts</span>
}

// Len return the size of the bucket
func (bucket *bucket) Len() int <span class="cov0" title="0">{
        return bucket.list.Len()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package kademlia

import (
        "fmt"
        "sort"
)

// Contact definition
// stores the KademliaID, the ip address and the distance
type Contact struct {
        ID       *KademliaID
        Address  string
        distance *KademliaID
}

// NewContact returns a new instance of a Contact
func NewContact(id *KademliaID, address string) Contact <span class="cov7" title="53">{
        return Contact{id, address, nil}
}</span>

// CalcDistance calculates the distance to the target and
// fills the contacts distance field
func (contact *Contact) CalcDistance(target *KademliaID) <span class="cov4" title="9">{
        contact.distance = contact.ID.CalcDistance(target)
}</span>

// Less returns true if contact.distance &lt; otherContact.distance
func (contact *Contact) Less(otherContact *Contact) bool <span class="cov6" title="21">{
        return contact.distance.Less(otherContact.distance)
}</span>

// String returns a simple string representation of a Contact
func (contact *Contact) String() string <span class="cov5" title="15">{
        return fmt.Sprintf(`contact("%s", "%s")`, contact.ID, contact.Address)
}</span>

// ContactCandidates definition
// stores an array of Contacts
type ContactCandidates struct {
        contacts []Contact
}

// Append an array of Contacts to the ContactCandidates
func (candidates *ContactCandidates) Append(contacts []Contact) <span class="cov9" title="162">{
        candidates.contacts = append(candidates.contacts, contacts...)
}</span>

// GetContacts returns the first count number of Contacts
func (candidates *ContactCandidates) GetContacts(count int) []Contact <span class="cov3" title="4">{
        if count &gt; len(candidates.contacts) </span><span class="cov2" title="2">{
                return candidates.contacts[:candidates.Len()]
        }</span>
        <span class="cov2" title="2">return candidates.contacts[:count]</span>
}

// Sort the Contacts in ContactCandidates
func (candidates *ContactCandidates) Sort() <span class="cov2" title="3">{
        sort.Sort(candidates)
}</span>

// Len returns the length of the ContactCandidates
func (candidates *ContactCandidates) Len() int <span class="cov10" title="167">{
        return len(candidates.contacts)
}</span>

// Swap the position of the Contacts at i and j
// WARNING does not check if either i or j is within range
func (candidates *ContactCandidates) Swap(i, j int) <span class="cov5" title="12">{
        candidates.contacts[i], candidates.contacts[j] = candidates.contacts[j], candidates.contacts[i]
}</span>

// Less returns true if the Contact at index i is smaller than
// the Contact at index j
func (candidates *ContactCandidates) Less(i, j int) bool <span class="cov6" title="21">{
        return candidates.contacts[i].Less(&amp;candidates.contacts[j])
}</span>

// Takes the shortlist and removes all the duplicate contacts
func (candidates *ContactCandidates) RemoveDuplicates() <span class="cov2" title="2">{
        newContactList := make([]Contact, 0)
        for _, contact := range candidates.contacts </span><span class="cov4" title="8">{
                duplicateExist := false
                for _, notDuplicateContact := range newContactList </span><span class="cov4" title="8">{
                        if contact.ID.String() == notDuplicateContact.ID.String() </span><span class="cov2" title="3">{
                                duplicateExist = true
                        }</span>
                }
                <span class="cov4" title="8">if !duplicateExist </span><span class="cov3" title="5">{
                        newContactList = append(newContactList, contact)
                }</span>
        }
        <span class="cov2" title="2">candidates.contacts = newContactList</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package kademlia

import (
        "crypto/sha1"
        "encoding/hex"
)

type Kademlia struct {
        alpha   int
        network *Network
}

func (kademlia *Kademlia) Start() <span class="cov0" title="0">{
        go kademlia.network.Listen()
}</span>

func (kademlia *Kademlia) Stop() <span class="cov0" title="0">{
        close(kademlia.network.routingTable.routingTableChan)
}</span>

func NewKademliaInstance(alpha int, me Contact) *Kademlia <span class="cov1" title="1">{
        network := NewNetwork(me)
        newKademliaInstance := &amp;Kademlia{alpha, network}
        return newKademliaInstance
}</span>

func (kademlia *Kademlia) LookupContact(target *Contact) *ContactCandidates <span class="cov0" title="0">{
        //Find k closest nodes
        closestNodes := kademlia.network.routingTable.FindClosestContacts(target.ID, kademlia.alpha)
        //Initiate closestNode
        closestNodesToContactCandidates := ContactCandidates{closestNodes}
        closestNodesToContactCandidates.Sort()
        closestContact := &amp;closestNodesToContactCandidates.contacts[0]
        //Initiate shortlist
        var shortlist ContactCandidates
        shortlist.contacts = closestNodes

        hasBeenContactedList := ContactCandidates{}

        closerNodeHasBeenFound := true
        for closerNodeHasBeenFound </span><span class="cov0" title="0">{
                //Send find node RPC to alpha number of contacts in the shortlist
                for i := 0; i &lt; kademlia.alpha; i++ </span><span class="cov0" title="0">{
                        go kademlia.network.SendFindContactMessage(&amp;shortlist.contacts[i], target)
                }</span>
                <span class="cov0" title="0">kademlia.manageShortlist(kademlia.alpha, &amp;shortlist)
                //Check end condition
                if shortlist.contacts[0].Less(closestContact) </span><span class="cov0" title="0">{
                        closestContact = &amp;shortlist.contacts[0]
                }</span> else<span class="cov0" title="0"> {
                        closerNodeHasBeenFound = false
                        //Find closest nodes that have not yet been contacted
                        nodesToContact := findNotContactedNodes(&amp;shortlist, &amp;hasBeenContactedList)
                        nodesToContact.Sort()
                        nodesToContact.RemoveDuplicates()
                        //Send a RPC to each of the k closest nodes that has not already been contacted
                        for _, nodeToContact := range nodesToContact.contacts </span><span class="cov0" title="0">{
                                go kademlia.network.SendFindContactMessage(&amp;nodeToContact, target)
                        }</span>
                        <span class="cov0" title="0">kademlia.manageShortlist(bucketSize, &amp;shortlist)
                        //Remove all inactive nodes from the shortlist
                        shortlist.contacts = removeInactiveNodes(shortlist, kademlia.network.inactiveNodes)</span>
                }
        }

        <span class="cov0" title="0">return &amp;shortlist</span>
}

func (kademlia *Kademlia) manageShortlist(alpha int, shortlist *ContactCandidates) <span class="cov1" title="1">{
        for i := 0; i &lt; alpha; i++ </span><span class="cov1" title="1">{
                newShortList := &lt;-kademlia.network.shortlistCh
                shortlist.Append(newShortList)
                shortlist.Sort()
                shortlist.RemoveDuplicates()
                shortlist.contacts = shortlist.GetContacts(bucketSize)
        }</span>

}

//Returns the contacts in the shortlis that haven't been contacted
func findNotContactedNodes(shortlist *ContactCandidates, contactedNodes *ContactCandidates) ContactCandidates <span class="cov1" title="1">{
        hasNotBeenContactedList := make([]Contact, 0)
        for _, contact := range shortlist.contacts </span><span class="cov4" title="2">{
                hasNotBeenContacted := true
                for _, contactedNode := range contactedNodes.contacts </span><span class="cov4" title="2">{
                        if contact.ID == contactedNode.ID </span><span class="cov1" title="1">{
                                hasNotBeenContacted = false
                        }</span>
                }
                <span class="cov4" title="2">if hasNotBeenContacted </span><span class="cov1" title="1">{
                        hasNotBeenContactedList = append(hasNotBeenContactedList, contact)
                }</span>
        }
        <span class="cov1" title="1">return ContactCandidates{hasNotBeenContactedList}</span>
}

func removeInactiveNodes(shortlist ContactCandidates, inactiveNodes ContactCandidates) []Contact <span class="cov1" title="1">{
        cleanShortlist := make([]Contact, 0)
        for _, contact := range shortlist.contacts </span><span class="cov6" title="3">{
                isActive := true
                for _, inactiveNode := range inactiveNodes.contacts </span><span class="cov10" title="6">{
                        if contact.ID == inactiveNode.ID </span><span class="cov4" title="2">{
                                isActive = false
                        }</span>
                }
                <span class="cov6" title="3">if isActive </span><span class="cov1" title="1">{
                        cleanShortlist = append(cleanShortlist, contact)
                }</span>
        }
        <span class="cov1" title="1">return cleanShortlist</span>
}

func (kademlia *Kademlia) LookupData(hash string) <span class="cov0" title="0">{
        // Make the hash into a kademliaID to be able to make a new contact
        hashToKademliaID := NewKademliaID(hash)
        kademliaToContact := NewContact(hashToKademliaID, "")
        // Look up the closests contacts
        shortlist := kademlia.LookupContact(&amp;kademliaToContact)

        //loop through all contact and find value
        for _, nodeToContact := range shortlist.contacts </span><span class="cov0" title="0">{
                kademlia.network.SendFindDataMessage(hash, &amp;nodeToContact)
        }</span>
}

func (kademlia *Kademlia) Store(data []byte) <span class="cov0" title="0">{
        //Hash the data to get a newKademliaID
        fileKademliaID := HashingData(data)
        newContact := NewContact(fileKademliaID, "")

        // Find closest contacts for the key
        closestsNodes := kademlia.LookupContact(&amp;newContact)

        //SendStore RPCs
        for _, nodeToStoreAt := range closestsNodes.contacts </span><span class="cov0" title="0">{
                go kademlia.network.SendStoreMessage(data, &amp;nodeToStoreAt)
        }</span>
}

func HashingData(data []byte) *KademliaID <span class="cov1" title="1">{
        //hash the data
        stringToBytes := sha1.New()
        stringToBytes.Write([]byte(data))
        hashedData := stringToBytes.Sum(nil)

        // Encodes the hash back to string to make it a new kademlia ID
        hashedStringData := hex.EncodeToString(hashedData)
        hashedKademliaID := NewKademliaID(hashedStringData)

        return hashedKademliaID
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package kademlia

import (
        "encoding/hex"
        "math/rand"
)

// the static number of bytes in a KademliaID
const IDLength = 20

// type definition of a KademliaID
type KademliaID [IDLength]byte

// NewKademliaID returns a new instance of a KademliaID based on the string input
func NewKademliaID(data string) *KademliaID <span class="cov6" title="81">{
        decoded, _ := hex.DecodeString(data)

        newKademliaID := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov10" title="1620">{
                newKademliaID[i] = decoded[i]
        }</span>

        <span class="cov6" title="81">return &amp;newKademliaID</span>
}

// NewRandomKademliaID returns a new instance of a random KademliaID,
// change this to a better version if you like
func NewRandomKademliaID() *KademliaID <span class="cov2" title="3">{
        newKademliaID := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov5" title="60">{
                newKademliaID[i] = uint8(rand.Intn(256))
        }</span>
        <span class="cov2" title="3">return &amp;newKademliaID</span>
}

// Less returns true if kademliaID &lt; otherKademliaID (bitwise)
func (kademliaID KademliaID) Less(otherKademliaID *KademliaID) bool <span class="cov4" title="24">{
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="346">{
                if kademliaID[i] != otherKademliaID[i] </span><span class="cov4" title="22">{
                        return kademliaID[i] &lt; otherKademliaID[i]
                }</span>
        }
        <span class="cov1" title="2">return false</span>
}

// Equals returns true if kademliaID == otherKademliaID (bitwise)
func (kademliaID KademliaID) Equals(otherKademliaID *KademliaID) bool <span class="cov4" title="16">{
        for i := 0; i &lt; IDLength; i++ </span><span class="cov7" title="148">{
                if kademliaID[i] != otherKademliaID[i] </span><span class="cov4" title="14">{
                        return false
                }</span>
        }
        <span class="cov1" title="2">return true</span>
}

// CalcDistance returns a new instance of a KademliaID that is built
// through a bitwise XOR operation betweeen kademliaID and target
func (kademliaID KademliaID) CalcDistance(target *KademliaID) *KademliaID <span class="cov4" title="17">{
        result := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="340">{
                result[i] = kademliaID[i] ^ target[i]
        }</span>
        <span class="cov4" title="17">return &amp;result</span>
}

// String returns a simple string representation of a KademliaID
func (kademliaID *KademliaID) String() string <span class="cov5" title="46">{
        return hex.EncodeToString(kademliaID[0:IDLength])
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package kademlia

import (
        "encoding/hex"
        "fmt"
        "net"
)

type Network struct {
        shortlistCh   chan []Contact //channel where shortlists from the goroutines will be written to
        inactiveNodes ContactCandidates
        routingTable  *RoutingTable
        storedValues  map[KademliaID]string
}

func NewNetwork(me Contact) *Network <span class="cov2" title="2">{
        shortlistCh := make(chan []Contact)
        inactiveNodes := ContactCandidates{[]Contact{}}
        routingTable := NewRoutingTable(me)
        storedValues := make(map[KademliaID]string)
        return &amp;Network{shortlistCh, inactiveNodes, routingTable, storedValues}
}</span>

// Listen acts as a global listener for incoming messages and processes each message depending on the type of the message
func (network *Network) Listen() <span class="cov0" title="0">{
        fmt.Println("Listening.....")
        p := make([]byte, 2048)
        addr := net.UDPAddr{
                Port: 8000,
                IP:   net.ParseIP(""),
        }
        conn, err := net.ListenUDP("udp", &amp;addr)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Some error %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, remoteaddr, err := conn.ReadFromUDP(p)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error reading from UDP stream")
                }</span> else<span class="cov0" title="0"> {
                        incomingMessage := hex.EncodeToString(p)
                        messageType, data, senderIDAsString := preprocessIncomingMessage(incomingMessage)
                        senderID := NewKademliaID(senderIDAsString)
                        sender := NewContact(senderID, remoteaddr.String())
                        switch messageType </span>{
                        case "FIND_NODE_RPC":<span class="cov0" title="0">
                                targetContactAsString := data
                                targetContact := StringToContact(targetContactAsString)
                                closestContacts := network.routingTable.FindClosestContacts(targetContact.ID, bucketSize)
                                shortlistAsString := shortlistToString(&amp;closestContacts)
                                //Send shortlist to sender
                                conn.WriteToUDP([]byte("SHORTLIST;"+shortlistAsString+";"+network.routingTable.me.ID.String()+"\n"), remoteaddr)
                                // Update buckets
                                go network.routingTable.AddContact(sender)</span>
                        case "FIND_VALUE_RPC":<span class="cov0" title="0"> //Lookup and return the value that's sought after
                                IDAsString := data
                                valueID := NewKademliaID(IDAsString)
                                value := network.storedValues[*valueID]
                                //Send value to sender
                                conn.WriteToUDP([]byte("VALUE;"+value+";"+network.routingTable.me.ID.String()+"\n"), remoteaddr)
                                // Update buckets
                                network.routingTable.AddContact(sender)</span>
                        case "STORE_VALUE_RPC":<span class="cov0" title="0">
                                valueID := HashingData([]byte(data))
                                network.storedValues[*valueID] = data
                                network.routingTable.AddContact(sender)</span>
                        case "SHORTLIST":<span class="cov0" title="0">
                                shortlistAsString := data
                                newShortlist := preprocessShortlist(shortlistAsString)
                                go network.addToShortlist(newShortlist)
                                network.routingTable.AddContact(sender)</span>
                        case "VALUE":<span class="cov0" title="0">
                                value := data
                                fmt.Println(value)
                                go network.routingTable.AddContact(sender)</span>
                        case "PING":<span class="cov0" title="0">
                                network.routingTable.AddContact(sender)
                                network.sendPongResponse(conn, remoteaddr)</span>
                        case "PONG":<span class="cov0" title="0">
                                network.routingTable.AddContact(sender)</span>
                        }
                }
        }

}

// Takes a message and returns message type, message data and sender ID
func preprocessIncomingMessage(message string) (string, string, string) <span class="cov3" title="6">{
        var messageType string
        var data string
        var senderID string
        numberOfEncounteredSemicolon := 0
        for _, letter := range message </span><span class="cov10" title="423">{
                if string(letter) == ";" </span><span class="cov4" title="12">{
                        numberOfEncounteredSemicolon += 1
                        continue</span>
                } else<span class="cov9" title="411"> if string(letter) == "\n" </span><span class="cov3" title="5">{ //All messages end with a newline character
                        break</span>
                }

                <span class="cov9" title="406">if numberOfEncounteredSemicolon == 0 </span><span class="cov7" title="64">{
                        messageType = messageType + string(letter)
                }</span> else<span class="cov9" title="342"> if numberOfEncounteredSemicolon == 1 </span><span class="cov8" title="137">{
                        data = data + string(letter)
                }</span> else<span class="cov8" title="205"> {
                        senderID = senderID + string(letter)
                }</span>
        }
        <span class="cov3" title="6">return messageType, data, senderID</span>
}

//When receiving a shortlist it will be a string with the structure that looks like this:
//        "contact(ID, IP);contact(ID, IP)..."
//This function will convert this string into a list containing all the contacts
func preprocessShortlist(shortlistString string) []Contact <span class="cov1" title="1">{
        var contactString string
        shortlist := make([]Contact, 0)
        for _, letter := range shortlistString </span><span class="cov8" title="135">{
                if string(letter) == ";" </span><span class="cov1" title="1">{
                        newContact := StringToContact(contactString)
                        shortlist = append(shortlist, newContact)
                        contactString = ""
                }</span> else<span class="cov8" title="134"> {
                        contactString = contactString + string(letter)
                }</span>
        }
        //Add last contact to shortlist
        <span class="cov1" title="1">newContact := StringToContact(contactString)
        shortlist = append(shortlist, newContact)
        return shortlist</span>
}

//Turns a list of contacts into a string with the format
//        contact("ID", "IP");contact("ID", "IP")...
func shortlistToString(shortlist *[]Contact) string <span class="cov2" title="2">{
        var shortlistString string
        for _, contact := range *shortlist </span><span class="cov3" title="4">{
                contactString := contact.String()
                shortlistString = shortlistString + contactString + ";"
        }</span>
        <span class="cov2" title="2">shortlistString = shortlistString[:len(shortlistString)-1] //remove last semicolon
        return shortlistString</span>
}

func (network *Network) addToShortlist(shortlist []Contact) <span class="cov0" title="0">{
        network.shortlistCh &lt;- shortlist
}</span>

//Takes as input a string structured as contact("ID", "IP") and converts it into a Contact
func StringToContact(contactAsString string) Contact <span class="cov2" title="3">{
        var address string
        var id string
        contactRune := []rune(contactAsString)
        hasReadID := false
        //Skip 8 first letters since they always start with "contact("
        for i := 8; i &lt; len(contactRune); i++ </span><span class="cov8" title="169">{
                if string(contactRune[i]) == ")" </span><span class="cov2" title="3">{
                        break</span>
                }
                <span class="cov8" title="166">if string(contactRune[i]) == "," </span><span class="cov2" title="3">{
                        hasReadID = true
                        i = i + 2
                }</span>
                <span class="cov8" title="166">if hasReadID </span><span class="cov6" title="40">{
                        address = address + string(contactRune[i])
                }</span> else<span class="cov8" title="126"> {
                        id = id + string(contactRune[i])
                }</span>
        }
        <span class="cov2" title="3">id = id[1 : len(id)-1]                //Remove " from beginning and end of string
        address = address[1 : len(address)-1] //Remove " from beginning and end of string
        newKademliaID := NewKademliaID(id)
        newContact := NewContact(newKademliaID, address)
        return newContact</span>

}

func (network *Network) SendPingMessage(contact *Contact) <span class="cov1" title="1">{
        conn, err := net.Dial("udp", contact.Address)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Somee error %v", err)
                return
        }</span>
        <span class="cov1" title="1">_, sendErr := fmt.Fprintf(conn, "PING;0;"+network.routingTable.me.ID.String()+"\n")
        if sendErr != nil </span><span class="cov0" title="0">{
                fmt.Printf("Some error %v\n", err)
        }</span>
        <span class="cov1" title="1">conn.Close()</span>
}

func (network *Network) sendPongResponse(conn *net.UDPConn, addr *net.UDPAddr) <span class="cov1" title="1">{
        _, err := conn.WriteToUDP([]byte("PONG;0;"+network.routingTable.me.ID.String()+"\n"), addr)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Couldn't send response %v", err)
        }</span>
}

func (network *Network) SendFindContactMessage(contact *Contact, target *Contact) <span class="cov1" title="1">{
        //Establish connection
        conn, err := net.Dial("udp", contact.Address)
        //Send contact to channel to mark as inactive
        if err != nil </span><span class="cov0" title="0">{
                network.shortlistCh &lt;- []Contact{}
                network.inactiveNodes.Append([]Contact{*contact})
        }</span>
        <span class="cov1" title="1">targetAsString := target.String()
        //Send find node rpc together with the target contact
        fmt.Fprintf(conn, "FIND_NODE_RPC;"+targetAsString+";"+network.routingTable.me.ID.String()+"\n")
        conn.Close()</span>
}

func (network *Network) SendFindDataMessage(ID string, contact *Contact) <span class="cov1" title="1">{
        conn, err := net.Dial("udp", contact.Address)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Some error %v\n", err)
        }</span>
        <span class="cov1" title="1">fmt.Fprintf(conn, "FIND_VALUE_RPC;"+ID+";"+network.routingTable.me.ID.String()+"\n")
        conn.Close()</span>
}

func (network *Network) SendStoreMessage(data []byte, contact *Contact) <span class="cov1" title="1">{
        conn, err := net.Dial("udp", contact.Address)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Some error %v\n", err)
        }</span>

        <span class="cov1" title="1">fmt.Fprintf(conn, "STORE_VALUE_RPC;"+string(data)+";"+network.routingTable.me.ID.String()+"\n")
        conn.Close()</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package kademlia

const bucketSize = 20

// RoutingTable definition
// keeps a refrence contact of me and an array of buckets
type RoutingTable struct {
        me               Contact
        buckets          [IDLength * 8]*bucket
        routingTableChan chan Contact
}

// NewRoutingTable returns a new instance of a RoutingTable
func NewRoutingTable(me Contact) *RoutingTable <span class="cov2" title="3">{
        routingTable := &amp;RoutingTable{}
        for i := 0; i &lt; IDLength*8; i++ </span><span class="cov10" title="480">{
                routingTable.buckets[i] = newBucket()
        }</span>
        <span class="cov2" title="3">routingTable.me = me
        return routingTable</span>
}

// addContactToBucket adds a new contact to the correct Bucket
func (routingTable *RoutingTable) AddContact(contact Contact) <span class="cov3" title="6">{
        bucketIndex := routingTable.getBucketIndex(contact.ID)
        bucket := routingTable.buckets[bucketIndex]
        bucket.AddContact(contact)
}</span>

// FindClosestContacts finds the count closest Contacts to the target in the RoutingTable
func (routingTable *RoutingTable) FindClosestContacts(target *KademliaID, count int) []Contact <span class="cov1" title="1">{
        var candidates ContactCandidates
        bucketIndex := routingTable.getBucketIndex(target)
        bucket := routingTable.buckets[bucketIndex]

        candidates.Append(bucket.GetContactAndCalcDistance(target))

        for i := 1; (bucketIndex-i &gt;= 0 || bucketIndex+i &lt; IDLength*8) &amp;&amp; candidates.Len() &lt; count; i++ </span><span class="cov8" title="159">{
                if bucketIndex-i &gt;= 0 </span><span class="cov0" title="0">{
                        bucket = routingTable.buckets[bucketIndex-i]
                        candidates.Append(bucket.GetContactAndCalcDistance(target))
                }</span>
                <span class="cov8" title="159">if bucketIndex+i &lt; IDLength*8 </span><span class="cov8" title="159">{
                        bucket = routingTable.buckets[bucketIndex+i]
                        candidates.Append(bucket.GetContactAndCalcDistance(target))
                }</span>
        }

        <span class="cov1" title="1">candidates.Sort()

        if count &gt; candidates.Len() </span><span class="cov1" title="1">{
                count = candidates.Len()
        }</span>

        <span class="cov1" title="1">return candidates.GetContacts(count)</span>
}

// getBucketIndex get the correct Bucket index for the KademliaID
func (routingTable *RoutingTable) getBucketIndex(id *KademliaID) int <span class="cov3" title="7">{
        distance := id.CalcDistance(routingTable.me.ID)
        for i := 0; i &lt; IDLength; i++ </span><span class="cov5" title="26">{
                for j := 0; j &lt; 8; j++ </span><span class="cov8" title="166">{
                        if (distance[i]&gt;&gt;uint8(7-j))&amp;0x1 != 0 </span><span class="cov3" title="6">{
                                return i*8 + j
                        }</span>
                }
        }

        <span class="cov1" title="1">return IDLength*8 - 1</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
