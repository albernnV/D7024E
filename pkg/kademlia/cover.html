
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>kademlia: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/albernnV/D7024E/pkg/kademlia/bucket.go (84.2%)</option>
				
				<option value="file1">github.com/albernnV/D7024E/pkg/kademlia/contact.go (52.6%)</option>
				
				<option value="file2">github.com/albernnV/D7024E/pkg/kademlia/kademlia.go (12.3%)</option>
				
				<option value="file3">github.com/albernnV/D7024E/pkg/kademlia/kademliaid.go (77.3%)</option>
				
				<option value="file4">github.com/albernnV/D7024E/pkg/kademlia/network.go (5.3%)</option>
				
				<option value="file5">github.com/albernnV/D7024E/pkg/kademlia/routingtable.go (79.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package kademlia

import (
        "container/list"
)

// bucket definition
// contains a List
type bucket struct {
        list *list.List
}

// newBucket returns a new instance of a bucket
func newBucket() *bucket <span class="cov8" title="1">{
        bucket := &amp;bucket{}
        bucket.list = list.New()
        return bucket
}</span>

// AddContact adds the Contact to the front of the bucket
// or moves it to the front of the bucket if it already existed
func (bucket *bucket) AddContact(contact Contact) <span class="cov8" title="1">{
        var element *list.Element
        for e := bucket.list.Front(); e != nil; e = e.Next() </span><span class="cov8" title="1">{
                nodeID := e.Value.(Contact).ID

                if (contact).ID.Equals(nodeID) </span><span class="cov0" title="0">{
                        element = e
                }</span>
        }

        <span class="cov8" title="1">if element == nil </span><span class="cov8" title="1">{
                if bucket.list.Len() &lt; bucketSize </span><span class="cov8" title="1">{
                        bucket.list.PushFront(contact)
                }</span>
        } else<span class="cov0" title="0"> {
                bucket.list.MoveToFront(element)
        }</span>
}

// GetContactAndCalcDistance returns an array of Contacts where 
// the distance has already been calculated
func (bucket *bucket) GetContactAndCalcDistance(target *KademliaID) []Contact <span class="cov8" title="1">{
        var contacts []Contact

        for elt := bucket.list.Front(); elt != nil; elt = elt.Next() </span><span class="cov8" title="1">{
                contact := elt.Value.(Contact)
                contact.CalcDistance(target)
                contacts = append(contacts, contact)
        }</span>

        <span class="cov8" title="1">return contacts</span>
}

// Len return the size of the bucket
func (bucket *bucket) Len() int <span class="cov0" title="0">{
        return bucket.list.Len()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package kademlia

import (
        "fmt"
        "sort"
)

// Contact definition
// stores the KademliaID, the ip address and the distance
type Contact struct {
        ID       *KademliaID
        Address  string
        distance *KademliaID
}

// NewContact returns a new instance of a Contact
func NewContact(id *KademliaID, address string) Contact <span class="cov8" title="1">{
        return Contact{id, address, nil}
}</span>

// CalcDistance calculates the distance to the target and
// fills the contacts distance field
func (contact *Contact) CalcDistance(target *KademliaID) <span class="cov8" title="1">{
        contact.distance = contact.ID.CalcDistance(target)
}</span>

// Less returns true if contact.distance &lt; otherContact.distance
func (contact *Contact) Less(otherContact *Contact) bool <span class="cov8" title="1">{
        return contact.distance.Less(otherContact.distance)
}</span>

// String returns a simple string representation of a Contact
func (contact *Contact) String() string <span class="cov8" title="1">{
        return fmt.Sprintf(`contact("%s", "%s")`, contact.ID, contact.Address)
}</span>

// ContactCandidates definition
// stores an array of Contacts
type ContactCandidates struct {
        contacts []Contact
}

// Append an array of Contacts to the ContactCandidates
func (candidates *ContactCandidates) Append(contacts []Contact) <span class="cov8" title="1">{
        candidates.contacts = append(candidates.contacts, contacts...)
}</span>

// GetContacts returns the first count number of Contacts
func (candidates *ContactCandidates) GetContacts(count int) []Contact <span class="cov8" title="1">{
        return candidates.contacts[:count]
}</span>

// Sort the Contacts in ContactCandidates
func (candidates *ContactCandidates) Sort() <span class="cov8" title="1">{
        sort.Sort(candidates)
}</span>

// Len returns the length of the ContactCandidates
func (candidates *ContactCandidates) Len() int <span class="cov8" title="1">{
        return len(candidates.contacts)
}</span>

// Swap the position of the Contacts at i and j
// WARNING does not check if either i or j is within range
func (candidates *ContactCandidates) Swap(i, j int) <span class="cov8" title="1">{
        candidates.contacts[i], candidates.contacts[j] = candidates.contacts[j], candidates.contacts[i]
}</span>

// Less returns true if the Contact at index i is smaller than
// the Contact at index j
func (candidates *ContactCandidates) Less(i, j int) bool <span class="cov8" title="1">{
        return candidates.contacts[i].Less(&amp;candidates.contacts[j])
}</span>

// Takes the shortlist and removes all the duplicate contacts
func (candidates *ContactCandidates) RemoveDuplicates() <span class="cov0" title="0">{
        newContactList := make([]Contact, 0)
        for _, contact := range candidates.contacts </span><span class="cov0" title="0">{
                duplicateExist := false
                for _, notDuplicateContact := range newContactList </span><span class="cov0" title="0">{
                        if contact.ID == notDuplicateContact.ID </span><span class="cov0" title="0">{
                                duplicateExist = true
                        }</span>
                }
                <span class="cov0" title="0">if !duplicateExist </span><span class="cov0" title="0">{
                        newContactList = append(newContactList, contact)
                }</span>
        }
        <span class="cov0" title="0">candidates.contacts = newContactList</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package kademlia

import (
        "crypto/sha1"
        "encoding/hex"
)

type Kademlia struct {
        alpha        int
        routingTable *RoutingTable
        network      *Network
}

func (kademlia *Kademlia) Start() <span class="cov0" title="0">{
        go kademlia.routingTable.UpdateRoutingTable()
}</span>

func (kademlia *Kademlia) Stop() <span class="cov0" title="0">{
        close(kademlia.routingTable.routingTableChan)
}</span>

func NewKademliaInstance(alpha int, me Contact) *Kademlia <span class="cov0" title="0">{
        routingTable := NewRoutingTable(me)
        network := &amp;Network{}
        newKademliaInstance := &amp;Kademlia{alpha, routingTable, network}
        return newKademliaInstance
}</span>

func (kademlia *Kademlia) LookupContact(target *Contact) *ContactCandidates <span class="cov0" title="0">{
        // TODO
        //FindClosestContacts() for target
        //
        //Check which node is closest to target, save in closestNode
        //
        //Input all alpha=3 contacts into a shortlist
        //
        //SendFindContactMessage() in parallel to the alpha nodes in the shortlist. These chould return k contacts. If anyone fails
        //to reply they are removed from the shortlist
        //
        //The node then fills the shortlist with contacts from the replies received. These are those closest to the target.
        //
        //update closestNode
        //
        //SendFindContactMessage() in parallel to another alpha nodes from the shortlist. The condition is that they haven't been
        //contacted already.
        //
        //continue until either no node in the returned sets are closer to the closest node seen or the initiating node has
        //accumulated k probed and known to be active contacts.
        //
        //If a cycle doesn't find a node that is closer than the already closest node the node will send a RPC each of
        //the k closest nodes that it has not already queried

        //Find k closest nodes
        closestNodes := kademlia.routingTable.FindClosestContacts(target.ID, kademlia.alpha)
        //Initiate closestNode
        closestNodesToContactCandidates := ContactCandidates{closestNodes}
        closestNodesToContactCandidates.Sort()
        closestContact := &amp;closestNodesToContactCandidates.contacts[0]
        //Initiate shortlist
        var shortlist ContactCandidates
        shortlist.contacts = closestNodes
        //Initiate channel where shortlists from the goroutines will be written to
        shortlistCh := make(chan []Contact)
        //Channel for writing inactive nodes to
        hasNotAnsweredCh := make(chan Contact)

        hasBeenContactedList := ContactCandidates{}
        hasNotAnsweredList := ContactCandidates{}

        closerNodeHasBeenFound := true
        go manageInactiveNodes(hasNotAnsweredCh, &amp;hasNotAnsweredList)
        for closerNodeHasBeenFound </span><span class="cov0" title="0">{
                //Send find node RPC to alpha number of contacts in the shortlist
                for i := 0; i &lt; kademlia.alpha; i++ </span><span class="cov0" title="0">{
                        go kademlia.SendFindNodeRPC(&amp;shortlist.contacts[i], target, kademlia.network, shortlistCh, hasNotAnsweredCh)
                }</span>
                <span class="cov0" title="0">manageShortlist(kademlia.alpha, &amp;shortlist, shortlistCh)
                //Check end condition
                if shortlist.contacts[0].Less(closestContact) </span><span class="cov0" title="0">{
                        closestContact = &amp;shortlist.contacts[0]
                }</span> else<span class="cov0" title="0"> {
                        closerNodeHasBeenFound = false
                        //Find closest nodes that have not yet been contacted
                        nodesToContact := findNotContactedNodes(&amp;shortlist, &amp;hasBeenContactedList)
                        nodesToContact.Sort()
                        nodesToContact.RemoveDuplicates()
                        //Send a RPC to each of the k closest nodes that has not already been contacted
                        for _, nodeToContact := range nodesToContact.GetContacts(bucketSize) </span><span class="cov0" title="0">{
                                go kademlia.SendFindNodeRPC(&amp;nodeToContact, target, kademlia.network, shortlistCh, hasNotAnsweredCh)
                        }</span>
                        <span class="cov0" title="0">manageShortlist(kademlia.alpha, &amp;shortlist, shortlistCh)
                        //Remove all inactive nodes from the shortlist
                        shortlist.contacts = removeInactiveNodes(shortlist, hasNotAnsweredList)</span>
                }
        }

        <span class="cov0" title="0">return &amp;shortlist</span>
}

//Sends a find node RPC to the contact which will send back the k closest nodes. These contacts will be written to the
//channel to be retireved
func (kademlia *Kademlia) SendFindNodeRPC(contact *Contact, target *Contact, network *Network, shortlistChannel chan []Contact, hasNotAnsweredChannel chan Contact) <span class="cov8" title="1">{
        closestNodes, didNotAnswer := network.SendFindContactMessage(contact, target, hasNotAnsweredChannel)
        shortlistChannel &lt;- closestNodes
        if didNotAnswer </span><span class="cov8" title="1">{
                hasNotAnsweredChannel &lt;- *contact
        }</span> else<span class="cov0" title="0"> {
                //Add contact to routing table
                kademlia.routingTable.routingTableChan &lt;- *contact
        }</span>
}

func manageShortlist(alpha int, shortlist *ContactCandidates, shortlistCh chan []Contact) <span class="cov0" title="0">{
        for i := 0; i &lt; alpha; i++ </span><span class="cov0" title="0">{
                newShortList := &lt;-shortlistCh
                shortlist.Append(newShortList)
                shortlist.Sort()
                shortlist.RemoveDuplicates()
                shortlist.contacts = shortlist.GetContacts(bucketSize)
        }</span>

}

//Returns the contacts in the shortlis that haven't been contacted
func findNotContactedNodes(shortlist *ContactCandidates, contactedNodes *ContactCandidates) ContactCandidates <span class="cov0" title="0">{
        hasNotBeenContactedList := make([]Contact, 0)
        for _, contact := range shortlist.contacts </span><span class="cov0" title="0">{
                hasNotBeenContacted := true
                for _, contactedNode := range contactedNodes.contacts </span><span class="cov0" title="0">{
                        if contact.ID == contactedNode.ID </span><span class="cov0" title="0">{
                                hasNotBeenContacted = false
                        }</span>
                }
                <span class="cov0" title="0">if hasNotBeenContacted </span><span class="cov0" title="0">{
                        hasNotBeenContactedList = append(hasNotBeenContactedList, contact)
                }</span>
        }
        <span class="cov0" title="0">return ContactCandidates{hasNotBeenContactedList}</span>
}

func manageInactiveNodes(hasNotAnsweredCh chan Contact, hasNotAnsweredList *ContactCandidates) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                inactiveNode := &lt;-hasNotAnsweredCh
                hasNotAnsweredList.Append([]Contact{inactiveNode})
        }</span>
}

//Removes all inactive nodes in inactiveNodes from shortlist
func removeInactiveNodes(shortlist ContactCandidates, inactiveNodes ContactCandidates) []Contact <span class="cov0" title="0">{
        cleanShortlist := make([]Contact, 0)
        for _, contact := range shortlist.contacts </span><span class="cov0" title="0">{
                isActive := true
                for _, inactiveNode := range inactiveNodes.contacts </span><span class="cov0" title="0">{
                        if contact.ID == inactiveNode.ID </span><span class="cov0" title="0">{
                                isActive = false
                        }</span>
                }
                <span class="cov0" title="0">if isActive </span><span class="cov0" title="0">{
                        cleanShortlist = append(cleanShortlist, contact)
                }</span>
        }
        <span class="cov0" title="0">return cleanShortlist</span>
}

func (kademlia *Kademlia) LookupData(hash string) <span class="cov0" title="0">{
        // Make the hash into a kademliaID to be able to make a new contact
        hashToKademliaID := NewKademliaID(hash)
        kademliaToContact := NewContact(hashToKademliaID, "")
        // Look up the closests contacts
        shortlist := kademlia.LookupContact(&amp;kademliaToContact)

        //loop through all contact and find value
        for _, nodeToContact := range shortlist.contacts </span><span class="cov0" title="0">{
                kademlia.network.SendFindDataMessage(hash, &amp;nodeToContact)
        }</span>
}

func (kademlia *Kademlia) Store(data []byte) <span class="cov0" title="0">{
        //Hash the data to get a newKademliaID
        fileKademliaID := HashingData(data)
        newContact := NewContact(fileKademliaID, "")

        // Find closest contacts for the key
        closestsNodes := kademlia.LookupContact(&amp;newContact)

        //SendStore RPCs
        for _, nodeToStoreAt := range closestsNodes.contacts </span><span class="cov0" title="0">{
                go kademlia.network.SendStoreMessage(data, &amp;nodeToStoreAt, newContact)
        }</span>

}

func HashingData(data []byte) *KademliaID <span class="cov8" title="1">{
        //hash the data
        stringToBytes := sha1.New()
        stringToBytes.Write([]byte(data))
        hashedData := stringToBytes.Sum(nil)

        // Encodes the hash back to string to make it a new kademlia ID
        hashedStringData := hex.EncodeToString(hashedData)
        hashedKademliaID := NewKademliaID(hashedStringData)

        return hashedKademliaID
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package kademlia

import (
        "encoding/hex"
        "math/rand"
)

// the static number of bytes in a KademliaID
const IDLength = 20

// type definition of a KademliaID
type KademliaID [IDLength]byte

// NewKademliaID returns a new instance of a KademliaID based on the string input
func NewKademliaID(data string) *KademliaID <span class="cov8" title="1">{
        decoded, _ := hex.DecodeString(data)

        newKademliaID := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                newKademliaID[i] = decoded[i]
        }</span>

        <span class="cov8" title="1">return &amp;newKademliaID</span>
}

// NewRandomKademliaID returns a new instance of a random KademliaID,
// change this to a better version if you like
func NewRandomKademliaID() *KademliaID <span class="cov0" title="0">{
        newKademliaID := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov0" title="0">{
                newKademliaID[i] = uint8(rand.Intn(256))
        }</span>
        <span class="cov0" title="0">return &amp;newKademliaID</span>
}

// Less returns true if kademliaID &lt; otherKademliaID (bitwise)
func (kademliaID KademliaID) Less(otherKademliaID *KademliaID) bool <span class="cov8" title="1">{
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                if kademliaID[i] != otherKademliaID[i] </span><span class="cov8" title="1">{
                        return kademliaID[i] &lt; otherKademliaID[i]
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Equals returns true if kademliaID == otherKademliaID (bitwise)
func (kademliaID KademliaID) Equals(otherKademliaID *KademliaID) bool <span class="cov8" title="1">{
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                if kademliaID[i] != otherKademliaID[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// CalcDistance returns a new instance of a KademliaID that is built
// through a bitwise XOR operation betweeen kademliaID and target
func (kademliaID KademliaID) CalcDistance(target *KademliaID) *KademliaID <span class="cov8" title="1">{
        result := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                result[i] = kademliaID[i] ^ target[i]
        }</span>
        <span class="cov8" title="1">return &amp;result</span>
}

// String returns a simple string representation of a KademliaID
func (kademliaID *KademliaID) String() string <span class="cov8" title="1">{
        return hex.EncodeToString(kademliaID[0:IDLength])
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package kademlia

import (
        "bufio"
        "encoding/hex"
        "fmt"
        "net"
)

type Network struct {
}

func Listen() <span class="cov0" title="0">{
        fmt.Println("Listening.....")
        p := make([]byte, 2048)
        addr := net.UDPAddr{
                Port: 8000,
                IP:   net.ParseIP(""),
        }
        ser, err := net.ListenUDP("udp", &amp;addr)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Some error %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, remoteaddr, err := ser.ReadFromUDP(p)
                fmt.Printf("Message receive from %v %s \n", remoteaddr, p)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Some error  %v", err)
                        continue</span>
                }
                <span class="cov0" title="0">go sendResponse(ser, remoteaddr)</span>
        }

}

func (network *Network) SendPingMessage() <span class="cov0" title="0">{
        p := make([]byte, 2048)
        conn, err := net.Dial("udp", "172.18.0.3:8000")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Somee error %v", err)
                return
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(conn, "PIIING")
        _, err = bufio.NewReader(conn).Read(p)
        if err == nil </span><span class="cov0" title="0">{
                fmt.Printf("%s\n", p)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Some error %v\n", err)
        }</span>
        <span class="cov0" title="0">conn.Close()</span>

}

func sendResponse(conn *net.UDPConn, addr *net.UDPAddr) <span class="cov0" title="0">{
        _, err := conn.WriteToUDP([]byte("POONG "), addr)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Couldn't send response %v", err)
        }</span>
}

func (network *Network) SendFindContactMessage(contact *Contact, target *Contact, hasNotAnsweredChannel chan Contact) ([]Contact, bool) <span class="cov8" title="1">{
        //Establish connection
        conn, err := net.Dial("tcp", contact.Address)
        //Send contact to channel to mark as inactive
        if err != nil </span><span class="cov8" title="1">{
                didNotAnswer := true
                return []Contact{}, didNotAnswer
        }</span>
        <span class="cov0" title="0">reader := bufio.NewReader(conn)
        targetAsString := target.String()
        //Send find node rpc together with the target contact
        fmt.Fprintf(conn, "FIND_NODE_RPC;"+targetAsString+"\n")
        //Wait for showrtlist as answer
        shortListString, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                didNotAnswer := true
                return []Contact{}, didNotAnswer
        }</span>
        <span class="cov0" title="0">shortList := preprocessShortlist(shortListString)
        didNotAnswer := false
        return shortList, didNotAnswer</span>
}

//When receiving a shortlist it will be a string with the structure that looks like this:
//        "contact(ID, IP);contact(ID, IP)..."
//This function will convert this string into a list containing all the contacts
func preprocessShortlist(shortlistString string) []Contact <span class="cov0" title="0">{
        var contactString string
        shortlist := make([]Contact, 0)
        for _, letter := range shortlistString </span><span class="cov0" title="0">{
                if string(letter) == ";" </span><span class="cov0" title="0">{
                        newContact := StringToContact(contactString)
                        shortlist = append(shortlist, newContact)
                        contactString = ""
                }</span> else<span class="cov0" title="0"> {
                        contactString = contactString + string(letter)
                }</span>
        }
        <span class="cov0" title="0">return shortlist</span>
}

//Takes as input a string structured as "contact(ID, IP) and converts it into a Contact"
func StringToContact(contactAsString string) Contact <span class="cov0" title="0">{
        var address string
        var id string
        contactRune := []rune(contactAsString)
        hasReadAddress := false
        //Skip 8 first letters since they always start with "contact("
        for i := 8; i &lt; len(contactRune); i++ </span><span class="cov0" title="0">{
                if string(contactRune[i]) == ")" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if string(contactRune[i]) == "," </span><span class="cov0" title="0">{
                        hasReadAddress = true
                        i = i + 2
                }</span>
                <span class="cov0" title="0">if hasReadAddress </span><span class="cov0" title="0">{
                        id = id + string(contactRune[i])
                }</span> else<span class="cov0" title="0"> {
                        address = address + string(contactRune[i])
                }</span>
        }
        <span class="cov0" title="0">newKademliaID := NewKademliaID(id)
        newContact := NewContact(newKademliaID, address)
        return newContact</span>

}

func (network *Network) SendFindDataMessage(ID string, contact *Contact) <span class="cov0" title="0">{
        conn, err := net.Dial("tcp", contact.Address)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Some error %v\n", err)
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(conn, "FIND_VALUE;"+ID+"\n")</span>

        /** A function call to Listen() is needed here but Listen()
        needs to be redone bc that should be the only function that listens **/

}

func (network *Network) SendStoreMessage(data []byte, contact *Contact, target Contact) <span class="cov0" title="0">{
        conn, err := net.Dial("tcp", contact.Address)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Some error %v\n", err)
        }</span>

        <span class="cov0" title="0">dataToString := hex.EncodeToString(data)
        fmt.Fprintf(conn, "SEND_STORE_RPC;"+dataToString+";"+target.ID.String())</span>
  
          /** A function call to Listen() is needed here but Listen()
        needs to be redone bc that should be the only function that listens **/
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package kademlia

const bucketSize = 20

// RoutingTable definition
// keeps a refrence contact of me and an array of buckets
type RoutingTable struct {
        me               Contact
        buckets          [IDLength * 8]*bucket
        routingTableChan chan Contact
}

// NewRoutingTable returns a new instance of a RoutingTable
func NewRoutingTable(me Contact) *RoutingTable <span class="cov8" title="1">{
        routingTable := &amp;RoutingTable{}
        for i := 0; i &lt; IDLength*8; i++ </span><span class="cov8" title="1">{
                routingTable.buckets[i] = newBucket()
        }</span>
        <span class="cov8" title="1">routingTable.me = me
        return routingTable</span>
}

// AddContact add a new contact to the correct Bucket
func (routingTable *RoutingTable) AddContact(contact Contact) <span class="cov8" title="1">{
        bucketIndex := routingTable.getBucketIndex(contact.ID)
        bucket := routingTable.buckets[bucketIndex]
        bucket.AddContact(contact)
}</span>

// FindClosestContacts finds the count closest Contacts to the target in the RoutingTable
func (routingTable *RoutingTable) FindClosestContacts(target *KademliaID, count int) []Contact <span class="cov8" title="1">{
        var candidates ContactCandidates
        bucketIndex := routingTable.getBucketIndex(target)
        bucket := routingTable.buckets[bucketIndex]

        candidates.Append(bucket.GetContactAndCalcDistance(target))

        for i := 1; (bucketIndex-i &gt;= 0 || bucketIndex+i &lt; IDLength*8) &amp;&amp; candidates.Len() &lt; count; i++ </span><span class="cov8" title="1">{
                if bucketIndex-i &gt;= 0 </span><span class="cov0" title="0">{
                        bucket = routingTable.buckets[bucketIndex-i]
                        candidates.Append(bucket.GetContactAndCalcDistance(target))
                }</span>
                <span class="cov8" title="1">if bucketIndex+i &lt; IDLength*8 </span><span class="cov8" title="1">{
                        bucket = routingTable.buckets[bucketIndex+i]
                        candidates.Append(bucket.GetContactAndCalcDistance(target))
                }</span>
        }

        <span class="cov8" title="1">candidates.Sort()

        if count &gt; candidates.Len() </span><span class="cov8" title="1">{
                count = candidates.Len()
        }</span>

        <span class="cov8" title="1">return candidates.GetContacts(count)</span>
}

// getBucketIndex get the correct Bucket index for the KademliaID
func (routingTable *RoutingTable) getBucketIndex(id *KademliaID) int <span class="cov8" title="1">{
        distance := id.CalcDistance(routingTable.me.ID)
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt; 8; j++ </span><span class="cov8" title="1">{
                        if (distance[i]&gt;&gt;uint8(7-j))&amp;0x1 != 0 </span><span class="cov8" title="1">{
                                return i*8 + j
                        }</span>
                }
        }

        <span class="cov8" title="1">return IDLength*8 - 1</span>
}

//This goroutine needs to be started from main so that we can update the routing table whenever we get a message from a node
func (routingTable *RoutingTable) UpdateRoutingTable() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                newContact, done := &lt;-routingTable.routingTableChan
                if done </span><span class="cov0" title="0">{ //Quits goroutine if channel is closed
                        return
                }</span>
                <span class="cov0" title="0">routingTable.AddContact(newContact)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
